<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>elpis.datasets.extract_annotations API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>elpis.datasets.extract_annotations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from itertools import chain
from pathlib import Path
from typing import List, Optional, Tuple

from loguru import logger
from pympi.Elan import Eaf

from elpis.models import Annotation, ElanOptions, ElanTierSelector


def extract_annotations(
    transcription_file: Path, elan_options: Optional[ElanOptions] = None
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Extracts annotations from the supplied transcription file.

    If the transcription file is an elan file, elan_options is required.

    Parameters:
        transcription_file: The file from which to extract annotations
        elan_options: Options to include for determining how to extract annotations
                from elan data.

    Returns:
        A list of found annotations.
        Returns an empty list if there was a problem.
    &#34;&#34;&#34;
    if transcription_file.suffix == &#34;.txt&#34;:
        return extract_text_annotations(transcription_file)

    if transcription_file.suffix != &#34;.eaf&#34;:
        logger.error(f&#34;Unrecognised file format: {transcription_file}&#34;)
        return []

    if elan_options is None:
        logger.error(f&#34;Missing elan options for extraction job.&#34;)
        return []

    return extract_elan_annotations(
        transcription_file,
        selection_type=elan_options.selection_mechanism,
        selection_data=elan_options.selection_value,
    )


def extract_text_annotations(file: Path) -&gt; List[Annotation]:
    &#34;&#34;&#34;Extract transcription information from a text file.

    Parameters:
        file_name: The name of the downloaded file.

    Returns:
        A list of utterance information for the given file.
    &#34;&#34;&#34;
    with open(file) as transcription_file:
        transcription = transcription_file.read()

    return [
        Annotation(
            audio_file=file.parent / (file.stem + &#34;.wav&#34;),
            transcript=transcription,
        )
    ]


def extract_elan_annotations(
    elan_file_path: Path, selection_type: ElanTierSelector, selection_data: str
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Extracts annotations from a particular tier in an eaf file (ELAN
    Annotation Format).

    Tiers are nodes from the tree structure in the .eaf file.
    The tier to read from is determined by tier order (eg top tier would be order 1),
    tier type (eg default-lt) or tier name (eg Phrase).

    Parameters:
        elan_file_path: The path to the eaf file.
        selection_type: The method of determining which tier data to extract.
        selection_data: The data corresponding to the selection_type.

    Returns:
        A list of the annotations contained for the supplied data. Returns an
        empty list if the given selection isn&#39;t found.
    &#34;&#34;&#34;
    match selection_type:
        case ElanTierSelector.NAME:
            return get_annotations_by_tier_name(elan_file_path, selection_data)
        case ElanTierSelector.TYPE:
            return get_annotations_by_tier_type(elan_file_path, selection_data)
        case ElanTierSelector.ORDER:
            try:
                order = int(selection_data)
            except:
                order = 1
            return get_annotations_by_tier_order(elan_file_path, order)


def get_annotations_by_tier_order(
    elan_file_path: Path, tier_order: int
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Retrieves all annotations for a given tier order within an eaf file.

    Parameters:
        elan_file_path: The path to the eaf file.
        tier_order: The tier order to extract from (starts at 1)

    Returns:
        A list of the annotations contained for the supplied tier order.
        Returns an empty list if the given tier order exceeds the nesting of
        the file.
    &#34;&#34;&#34;
    elan = Eaf(elan_file_path)

    tier_names: List[str] = list(elan.get_tier_names())
    if tier_order &gt; len(tier_names):
        logger.error(
            f&#34;tier_order: {tier_order} exceeds tier length for {elan_file_path}&#34;
        )
        return []

    tier_name = tier_names[tier_order - 1]
    return get_annotations_by_tier_name(
        elan_file_path=elan_file_path, tier_name=tier_name
    )


def get_annotations_by_tier_type(
    elan_file_path: Path, tier_type: str
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Retrieves all annotations for a given linguistic tier type in an eaf file.

    Parameters:
        elan_file_path: The path to the eaf file.
        tier_type: The linguistic type from which to extract Annotation data.

    Returns:
        A list of the annotations contained for the supplied linguistic type.
        Returns an empty list if the type is not found.
    &#34;&#34;&#34;
    elan = Eaf(elan_file_path)

    if tier_type not in list(elan.get_linguistic_type_names()):
        logger.error(f&#34;tier_type: {tier_type} not found in file: {elan_file_path}&#34;)
        return []

    tier_names = elan.get_tier_ids_for_linguistic_type(tier_type)
    annotations = (
        get_annotations_by_tier_name(elan_file_path, name) for name in tier_names
    )
    # Flatten list of annotations
    return list(chain(*annotations))


def get_annotations_by_tier_name(
    elan_file_path: Path, tier_name: str
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Retrieves all annotations for a given tier name in an eaf file.

    Parameters:
        elan_file_path: The path to the eaf file.
        tier_name: The tier name from which to extract Annotation data.

    Returns:
        A list of the annotations contained for the supplied tier name.
        Returns an empty list if the name is not found.
    &#34;&#34;&#34;
    elan = Eaf(elan_file_path)

    if tier_name not in list(elan.get_tier_names()):
        logger.error(f&#34;tier_name: {tier_name} not found in file {elan_file_path}&#34;)
        return []

    def create_annotation(elan_annotation: Tuple[str, str, str]) -&gt; Annotation:
        start, end, transcript = elan_annotation
        return Annotation(
            audio_file=elan_file_path.parent / (elan_file_path.stem + &#34;.wav&#34;),
            transcript=transcript,
            start_ms=int(start),
            stop_ms=int(end),
        )

    return list(map(create_annotation, elan.get_annotation_data_for_tier(tier_name)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="elpis.datasets.extract_annotations.extract_annotations"><code class="name flex">
<span>def <span class="ident">extract_annotations</span></span>(<span>transcription_file: pathlib.Path, elan_options: Optional[<a title="elpis.models.elan_options.ElanOptions" href="../models/elan_options.html#elpis.models.elan_options.ElanOptions">ElanOptions</a>] = None) ‑> List[<a title="elpis.models.annotation.Annotation" href="../models/annotation.html#elpis.models.annotation.Annotation">Annotation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts annotations from the supplied transcription file.</p>
<p>If the transcription file is an elan file, elan_options is required.</p>
<h2 id="parameters">Parameters</h2>
<p>transcription_file: The file from which to extract annotations
elan_options: Options to include for determining how to extract annotations
from elan data.</p>
<h2 id="returns">Returns</h2>
<p>A list of found annotations.
Returns an empty list if there was a problem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_annotations(
    transcription_file: Path, elan_options: Optional[ElanOptions] = None
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Extracts annotations from the supplied transcription file.

    If the transcription file is an elan file, elan_options is required.

    Parameters:
        transcription_file: The file from which to extract annotations
        elan_options: Options to include for determining how to extract annotations
                from elan data.

    Returns:
        A list of found annotations.
        Returns an empty list if there was a problem.
    &#34;&#34;&#34;
    if transcription_file.suffix == &#34;.txt&#34;:
        return extract_text_annotations(transcription_file)

    if transcription_file.suffix != &#34;.eaf&#34;:
        logger.error(f&#34;Unrecognised file format: {transcription_file}&#34;)
        return []

    if elan_options is None:
        logger.error(f&#34;Missing elan options for extraction job.&#34;)
        return []

    return extract_elan_annotations(
        transcription_file,
        selection_type=elan_options.selection_mechanism,
        selection_data=elan_options.selection_value,
    )</code></pre>
</details>
</dd>
<dt id="elpis.datasets.extract_annotations.extract_elan_annotations"><code class="name flex">
<span>def <span class="ident">extract_elan_annotations</span></span>(<span>elan_file_path: pathlib.Path, selection_type: <a title="elpis.models.elan_options.ElanTierSelector" href="../models/elan_options.html#elpis.models.elan_options.ElanTierSelector">ElanTierSelector</a>, selection_data: str) ‑> List[<a title="elpis.models.annotation.Annotation" href="../models/annotation.html#elpis.models.annotation.Annotation">Annotation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts annotations from a particular tier in an eaf file (ELAN
Annotation Format).</p>
<p>Tiers are nodes from the tree structure in the .eaf file.
The tier to read from is determined by tier order (eg top tier would be order 1),
tier type (eg default-lt) or tier name (eg Phrase).</p>
<h2 id="parameters">Parameters</h2>
<p>elan_file_path: The path to the eaf file.
selection_type: The method of determining which tier data to extract.
selection_data: The data corresponding to the selection_type.</p>
<h2 id="returns">Returns</h2>
<p>A list of the annotations contained for the supplied data. Returns an
empty list if the given selection isn't found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_elan_annotations(
    elan_file_path: Path, selection_type: ElanTierSelector, selection_data: str
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Extracts annotations from a particular tier in an eaf file (ELAN
    Annotation Format).

    Tiers are nodes from the tree structure in the .eaf file.
    The tier to read from is determined by tier order (eg top tier would be order 1),
    tier type (eg default-lt) or tier name (eg Phrase).

    Parameters:
        elan_file_path: The path to the eaf file.
        selection_type: The method of determining which tier data to extract.
        selection_data: The data corresponding to the selection_type.

    Returns:
        A list of the annotations contained for the supplied data. Returns an
        empty list if the given selection isn&#39;t found.
    &#34;&#34;&#34;
    match selection_type:
        case ElanTierSelector.NAME:
            return get_annotations_by_tier_name(elan_file_path, selection_data)
        case ElanTierSelector.TYPE:
            return get_annotations_by_tier_type(elan_file_path, selection_data)
        case ElanTierSelector.ORDER:
            try:
                order = int(selection_data)
            except:
                order = 1
            return get_annotations_by_tier_order(elan_file_path, order)</code></pre>
</details>
</dd>
<dt id="elpis.datasets.extract_annotations.extract_text_annotations"><code class="name flex">
<span>def <span class="ident">extract_text_annotations</span></span>(<span>file: pathlib.Path) ‑> List[<a title="elpis.models.annotation.Annotation" href="../models/annotation.html#elpis.models.annotation.Annotation">Annotation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract transcription information from a text file.</p>
<h2 id="parameters">Parameters</h2>
<p>file_name: The name of the downloaded file.</p>
<h2 id="returns">Returns</h2>
<p>A list of utterance information for the given file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_text_annotations(file: Path) -&gt; List[Annotation]:
    &#34;&#34;&#34;Extract transcription information from a text file.

    Parameters:
        file_name: The name of the downloaded file.

    Returns:
        A list of utterance information for the given file.
    &#34;&#34;&#34;
    with open(file) as transcription_file:
        transcription = transcription_file.read()

    return [
        Annotation(
            audio_file=file.parent / (file.stem + &#34;.wav&#34;),
            transcript=transcription,
        )
    ]</code></pre>
</details>
</dd>
<dt id="elpis.datasets.extract_annotations.get_annotations_by_tier_name"><code class="name flex">
<span>def <span class="ident">get_annotations_by_tier_name</span></span>(<span>elan_file_path: pathlib.Path, tier_name: str) ‑> List[<a title="elpis.models.annotation.Annotation" href="../models/annotation.html#elpis.models.annotation.Annotation">Annotation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all annotations for a given tier name in an eaf file.</p>
<h2 id="parameters">Parameters</h2>
<p>elan_file_path: The path to the eaf file.
tier_name: The tier name from which to extract Annotation data.</p>
<h2 id="returns">Returns</h2>
<p>A list of the annotations contained for the supplied tier name.
Returns an empty list if the name is not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotations_by_tier_name(
    elan_file_path: Path, tier_name: str
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Retrieves all annotations for a given tier name in an eaf file.

    Parameters:
        elan_file_path: The path to the eaf file.
        tier_name: The tier name from which to extract Annotation data.

    Returns:
        A list of the annotations contained for the supplied tier name.
        Returns an empty list if the name is not found.
    &#34;&#34;&#34;
    elan = Eaf(elan_file_path)

    if tier_name not in list(elan.get_tier_names()):
        logger.error(f&#34;tier_name: {tier_name} not found in file {elan_file_path}&#34;)
        return []

    def create_annotation(elan_annotation: Tuple[str, str, str]) -&gt; Annotation:
        start, end, transcript = elan_annotation
        return Annotation(
            audio_file=elan_file_path.parent / (elan_file_path.stem + &#34;.wav&#34;),
            transcript=transcript,
            start_ms=int(start),
            stop_ms=int(end),
        )

    return list(map(create_annotation, elan.get_annotation_data_for_tier(tier_name)))</code></pre>
</details>
</dd>
<dt id="elpis.datasets.extract_annotations.get_annotations_by_tier_order"><code class="name flex">
<span>def <span class="ident">get_annotations_by_tier_order</span></span>(<span>elan_file_path: pathlib.Path, tier_order: int) ‑> List[<a title="elpis.models.annotation.Annotation" href="../models/annotation.html#elpis.models.annotation.Annotation">Annotation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all annotations for a given tier order within an eaf file.</p>
<h2 id="parameters">Parameters</h2>
<p>elan_file_path: The path to the eaf file.
tier_order: The tier order to extract from (starts at 1)</p>
<h2 id="returns">Returns</h2>
<p>A list of the annotations contained for the supplied tier order.
Returns an empty list if the given tier order exceeds the nesting of
the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotations_by_tier_order(
    elan_file_path: Path, tier_order: int
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Retrieves all annotations for a given tier order within an eaf file.

    Parameters:
        elan_file_path: The path to the eaf file.
        tier_order: The tier order to extract from (starts at 1)

    Returns:
        A list of the annotations contained for the supplied tier order.
        Returns an empty list if the given tier order exceeds the nesting of
        the file.
    &#34;&#34;&#34;
    elan = Eaf(elan_file_path)

    tier_names: List[str] = list(elan.get_tier_names())
    if tier_order &gt; len(tier_names):
        logger.error(
            f&#34;tier_order: {tier_order} exceeds tier length for {elan_file_path}&#34;
        )
        return []

    tier_name = tier_names[tier_order - 1]
    return get_annotations_by_tier_name(
        elan_file_path=elan_file_path, tier_name=tier_name
    )</code></pre>
</details>
</dd>
<dt id="elpis.datasets.extract_annotations.get_annotations_by_tier_type"><code class="name flex">
<span>def <span class="ident">get_annotations_by_tier_type</span></span>(<span>elan_file_path: pathlib.Path, tier_type: str) ‑> List[<a title="elpis.models.annotation.Annotation" href="../models/annotation.html#elpis.models.annotation.Annotation">Annotation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all annotations for a given linguistic tier type in an eaf file.</p>
<h2 id="parameters">Parameters</h2>
<p>elan_file_path: The path to the eaf file.
tier_type: The linguistic type from which to extract Annotation data.</p>
<h2 id="returns">Returns</h2>
<p>A list of the annotations contained for the supplied linguistic type.
Returns an empty list if the type is not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotations_by_tier_type(
    elan_file_path: Path, tier_type: str
) -&gt; List[Annotation]:
    &#34;&#34;&#34;Retrieves all annotations for a given linguistic tier type in an eaf file.

    Parameters:
        elan_file_path: The path to the eaf file.
        tier_type: The linguistic type from which to extract Annotation data.

    Returns:
        A list of the annotations contained for the supplied linguistic type.
        Returns an empty list if the type is not found.
    &#34;&#34;&#34;
    elan = Eaf(elan_file_path)

    if tier_type not in list(elan.get_linguistic_type_names()):
        logger.error(f&#34;tier_type: {tier_type} not found in file: {elan_file_path}&#34;)
        return []

    tier_names = elan.get_tier_ids_for_linguistic_type(tier_type)
    annotations = (
        get_annotations_by_tier_name(elan_file_path, name) for name in tier_names
    )
    # Flatten list of annotations
    return list(chain(*annotations))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="elpis.datasets" href="index.html">elpis.datasets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="elpis.datasets.extract_annotations.extract_annotations" href="#elpis.datasets.extract_annotations.extract_annotations">extract_annotations</a></code></li>
<li><code><a title="elpis.datasets.extract_annotations.extract_elan_annotations" href="#elpis.datasets.extract_annotations.extract_elan_annotations">extract_elan_annotations</a></code></li>
<li><code><a title="elpis.datasets.extract_annotations.extract_text_annotations" href="#elpis.datasets.extract_annotations.extract_text_annotations">extract_text_annotations</a></code></li>
<li><code><a title="elpis.datasets.extract_annotations.get_annotations_by_tier_name" href="#elpis.datasets.extract_annotations.get_annotations_by_tier_name">get_annotations_by_tier_name</a></code></li>
<li><code><a title="elpis.datasets.extract_annotations.get_annotations_by_tier_order" href="#elpis.datasets.extract_annotations.get_annotations_by_tier_order">get_annotations_by_tier_order</a></code></li>
<li><code><a title="elpis.datasets.extract_annotations.get_annotations_by_tier_type" href="#elpis.datasets.extract_annotations.get_annotations_by_tier_type">get_annotations_by_tier_type</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>